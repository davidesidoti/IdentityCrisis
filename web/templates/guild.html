{% extends "base.html" %}

{% block title %}Server Settings - IdentityCrisis{% endblock %}

{% block content %}
<div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-12" x-data="guildSettings('{{ guild_id }}')">
    <!-- Back button -->
    <a href="/dashboard" class="inline-flex items-center text-gray-400 hover:text-white mb-6 transition-colors">
        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
        </svg>
        Back to Dashboard
    </a>
    
    <!-- Loading state -->
    <div x-show="loading" class="flex justify-center py-12">
        <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-discord-blurple"></div>
    </div>
    
    <!-- Content -->
    <div x-show="!loading" x-cloak>
        <!-- Header -->
        <div class="flex items-center space-x-4 mb-8">
            <template x-if="guild.icon_url">
                <img :src="guild.icon_url" :alt="guild.name" class="w-16 h-16 rounded-xl">
            </template>
            <template x-if="!guild.icon_url">
                <div class="w-16 h-16 rounded-xl bg-discord-light flex items-center justify-center text-2xl font-bold text-gray-400"
                     x-text="guild.name ? guild.name.charAt(0).toUpperCase() : '?'">
                </div>
            </template>
            <div>
                <h1 class="text-2xl font-bold text-white" x-text="guild.name"></h1>
                <p class="text-gray-400">Server Settings</p>
            </div>
        </div>
        
        <!-- Settings Card -->
        <div class="bg-discord-dark rounded-xl border border-gray-700 mb-8">
            <div class="p-6 border-b border-gray-700">
                <h2 class="text-lg font-semibold text-white">General Settings</h2>
            </div>
            <div class="p-6 space-y-6">
                <!-- Enabled toggle -->
                <div class="flex items-center justify-between">
                    <div>
                        <h3 class="text-white font-medium">Enable Bot</h3>
                        <p class="text-sm text-gray-400">Turn nickname chaos on or off for this server</p>
                    </div>
                    <button @click="toggleEnabled()" 
                            :class="guild.enabled ? 'bg-discord-green' : 'bg-gray-600'"
                            class="relative inline-flex h-6 w-11 items-center rounded-full transition-colors">
                        <span :class="guild.enabled ? 'translate-x-6' : 'translate-x-1'"
                              class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform"></span>
                    </button>
                </div>
                
                <!-- Restore on leave toggle -->
                <div class="flex items-center justify-between">
                    <div>
                        <h3 class="text-white font-medium">Restore Nickname on Leave</h3>
                        <p class="text-sm text-gray-400">Restore original nickname when user leaves voice channel</p>
                    </div>
                    <button @click="toggleRestore()" 
                            :class="guild.restore_on_leave ? 'bg-discord-green' : 'bg-gray-600'"
                            class="relative inline-flex h-6 w-11 items-center rounded-full transition-colors">
                        <span :class="guild.restore_on_leave ? 'translate-x-6' : 'translate-x-1'"
                              class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform"></span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Member Reset Nicknames Card -->
        <div class="bg-discord-dark rounded-xl border border-gray-700 mb-8">
            <div class="p-6 border-b border-gray-700 flex items-center justify-between">
                <div>
                    <h2 class="text-lg font-semibold text-white">Member Reset Nicknames</h2>
                    <p class="text-sm text-gray-400">Set the nickname used when a member leaves voice.</p>
                </div>
                <div class="flex items-center gap-3">
                    <button @click="manualRefreshMemberNicknames()"
                            :disabled="memberLoading"
                            class="px-3 py-1.5 bg-gray-700 hover:bg-gray-600 disabled:bg-gray-800 disabled:cursor-not-allowed rounded text-white text-xs font-medium transition-colors">
                        Refresh
                    </button>
                    <span class="text-sm text-gray-500" x-text="memberTotal + ' member(s)'"></span>
                </div>
            </div>
            <div class="p-6">
                <div class="flex items-center justify-between text-xs text-gray-500 mb-4">
                    <span x-text="'Auto-clean: inactive for ' + memberStaleDays + ' days'"></span>
                    <span x-text="memberLastRefresh ? 'Last refresh: ' + memberLastRefresh : 'Last refresh: -'"></span>
                    <span x-show="memberLoading">Loading...</span>
                </div>

                <div x-show="memberNicknames.length > 0" class="space-y-3">
                    <template x-for="member in memberNicknames" :key="member.user_id">
                        <div class="bg-discord-darker rounded-lg px-4 py-3">
                            <div class="flex items-center justify-between mb-3">
                                <div>
                                    <p class="text-white font-medium" x-text="member.display_name"></p>
                                    <p class="text-xs text-gray-500" x-text="'@' + member.username + ' | ' + member.user_id"></p>
                                </div>
                                <span class="text-xs text-gray-500" x-text="formatLastSeen(member.last_seen_at)"></span>
                            </div>
                            <div class="flex flex-col gap-2 sm:flex-row sm:items-center">
                                <input type="text"
                                       x-model="member.reset_nickname_input"
                                       maxlength="32"
                                       placeholder="Reset nickname (leave empty to clear)"
                                       class="flex-1 bg-discord-dark border border-gray-600 rounded-lg px-3 py-2 text-white placeholder-gray-500 focus:outline-none focus:border-discord-blurple text-sm">
                                <div class="flex gap-2">
                                    <button @click="saveMemberNickname(member)"
                                            class="px-3 py-2 bg-discord-blurple hover:bg-opacity-80 rounded-lg text-white text-sm font-medium transition-colors">
                                        Save
                                    </button>
                                    <button @click="removeMemberNickname(member)"
                                            class="px-3 py-2 bg-discord-red hover:bg-opacity-80 rounded-lg text-white text-sm font-medium transition-colors">
                                        Remove
                                    </button>
                                </div>
                            </div>
                            <p class="text-xs text-gray-500 mt-2" x-show="!member.reset_nickname_manual">
                                Auto: updated on each voice join
                            </p>
                        </div>
                    </template>
                </div>

                <div x-show="memberNicknames.length === 0 && !memberLoading" class="text-center py-8 text-gray-500">
                    <p>No members yet. Join a voice channel to populate this list.</p>
                </div>

                <div class="flex items-center justify-between mt-4">
                    <button @click="prevMemberPage()"
                            :disabled="memberPage <= 1"
                            class="px-3 py-1.5 bg-gray-700 hover:bg-gray-600 disabled:bg-gray-800 disabled:cursor-not-allowed rounded text-white text-sm">
                        Prev
                    </button>
                    <span class="text-xs text-gray-500" x-text="memberPageText()"></span>
                    <button @click="nextMemberPage()"
                            :disabled="memberPage >= memberPageCount()"
                            class="px-3 py-1.5 bg-gray-700 hover:bg-gray-600 disabled:bg-gray-800 disabled:cursor-not-allowed rounded text-white text-sm">
                        Next
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Nicknames Card -->
        <div class="bg-discord-dark rounded-xl border border-gray-700 mb-8">
            <div class="p-6 border-b border-gray-700 flex items-center justify-between">
                <div>
                    <h2 class="text-lg font-semibold text-white">Custom Nicknames</h2>
                    <p class="text-sm text-gray-400">Add your own nicknames. Leave empty to use defaults.</p>
                </div>
                <span class="text-sm text-gray-500" x-text="nicknames.length + ' nickname(s)'"></span>
            </div>
            <div class="p-6">
                <!-- Add nickname form -->
                <form @submit.prevent="addNickname()" class="flex gap-3 mb-6">
                    <input type="text" 
                           x-model="newNickname"
                           maxlength="32"
                           placeholder="Enter a nickname..."
                           class="flex-1 bg-discord-darker border border-gray-600 rounded-lg px-4 py-2 text-white placeholder-gray-500 focus:outline-none focus:border-discord-blurple">
                    <button type="submit" 
                            :disabled="!newNickname.trim()"
                            class="px-4 py-2 bg-discord-blurple hover:bg-opacity-80 disabled:bg-gray-600 disabled:cursor-not-allowed rounded-lg text-white font-medium transition-colors">
                        Add
                    </button>
                </form>
                
                <!-- Nickname list -->
                <div x-show="nicknames.length > 0" class="space-y-2">
                    <template x-for="nickname in nicknames" :key="nickname.id">
                        <div class="flex items-center justify-between bg-discord-darker rounded-lg px-4 py-3 group">
                            <span class="text-gray-300" x-text="nickname.nickname"></span>
                            <button @click="deleteNickname(nickname.id)"
                                    class="text-gray-500 hover:text-discord-red opacity-0 group-hover:opacity-100 transition-all">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                                </svg>
                            </button>
                        </div>
                    </template>
                </div>
                
                <!-- Empty state -->
                <div x-show="nicknames.length === 0" class="text-center py-8 text-gray-500">
                    <p>No custom nicknames. Using default list.</p>
                </div>
            </div>
        </div>
        
        <!-- Included Channels Card -->
        <div class="bg-discord-dark rounded-xl border border-gray-700">
            <div class="p-6 border-b border-gray-700 flex items-center justify-between">
                <div>
                    <h2 class="text-lg font-semibold text-white">Included Channels</h2>
                    <p class="text-sm text-gray-400">Voice channels where the bot will work. Leave empty for all channels.</p>
                </div>
                <span class="text-sm text-gray-500" x-text="includedChannels.length + ' channel(s)'"></span>
            </div>
            <div class="p-6">
                <!-- Add channel form -->
                <form @submit.prevent="addIncludedChannel()" class="flex gap-3 mb-6">
                    <input type="text" 
                           x-model="newChannelId"
                           placeholder="Channel ID"
                           class="w-48 bg-discord-darker border border-gray-600 rounded-lg px-4 py-2 text-white placeholder-gray-500 focus:outline-none focus:border-discord-blurple">
                    <input type="text" 
                           x-model="newChannelName"
                           placeholder="Channel Name (for display)"
                           class="flex-1 bg-discord-darker border border-gray-600 rounded-lg px-4 py-2 text-white placeholder-gray-500 focus:outline-none focus:border-discord-blurple">
                    <button type="submit" 
                            :disabled="!newChannelId.trim() || !newChannelName.trim()"
                            class="px-4 py-2 bg-discord-blurple hover:bg-opacity-80 disabled:bg-gray-600 disabled:cursor-not-allowed rounded-lg text-white font-medium transition-colors">
                        Add
                    </button>
                </form>
                <p class="text-xs text-gray-500 mb-4">
                    To get a channel ID: Enable Developer Mode in Discord settings, right-click the channel, and click "Copy Channel ID"
                </p>
                
                <!-- Info box -->
                <div class="mb-4 p-3 bg-discord-blurple/10 border border-discord-blurple/30 rounded-lg">
                    <p class="text-sm text-gray-300">
                        <span class="text-discord-blurple font-medium">Tip:</span> 
                        If no channels are added, the bot works on <strong>all</strong> voice channels.
                        Add channels here to make the bot work <strong>only</strong> on those specific channels.
                    </p>
                </div>
                
                <!-- Channel list -->
                <div x-show="includedChannels.length > 0" class="space-y-2">
                    <template x-for="channel in includedChannels" :key="channel.id">
                        <div class="flex items-center justify-between bg-discord-darker rounded-lg px-4 py-3 group">
                            <div>
                                <span class="text-gray-300" x-text="channel.channel_name"></span>
                                <span class="text-xs text-gray-500 ml-2" x-text="'#' + channel.channel_id"></span>
                            </div>
                            <button @click="removeIncludedChannel(channel.id)"
                                    class="text-gray-500 hover:text-discord-red opacity-0 group-hover:opacity-100 transition-all">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                                </svg>
                            </button>
                        </div>
                    </template>
                </div>
                
                <!-- Empty state -->
                <div x-show="includedChannels.length === 0" class="text-center py-8 text-gray-500">
                    <p>No channels added. Bot is active on <strong>all</strong> voice channels.</p>
                </div>
            </div>
        </div>

		<!-- Custom Channels Card -->
        <div class="bg-discord-dark rounded-xl border border-gray-700 mt-8">
            <div class="p-6 border-b border-gray-700 flex items-center justify-between">
                <div>
                    <h2 class="text-lg font-semibold text-white">Custom Channel Rules</h2>
                    <p class="text-sm text-gray-400">Apply name transformations in specific voice channels.</p>
                </div>
                <span class="text-sm text-gray-500" x-text="customChannels.length + ' channel(s)'"></span>
            </div>
            <div class="p-6">
                <!-- Add custom channel form -->
                <div class="mb-6 p-4 bg-discord-darker rounded-lg">
                    <div class="flex gap-3 mb-4">
                        <input type="text" 
                               x-model="newCustomChannelId"
                               placeholder="Channel ID"
                               class="w-48 bg-discord-dark border border-gray-600 rounded-lg px-4 py-2 text-white placeholder-gray-500 focus:outline-none focus:border-discord-blurple">
                        <input type="text" 
                               x-model="newCustomChannelName"
                               placeholder="Channel Name"
                               class="flex-1 bg-discord-dark border border-gray-600 rounded-lg px-4 py-2 text-white placeholder-gray-500 focus:outline-none focus:border-discord-blurple">
                    </div>
                    
                    <!-- Rule selector -->
                    <div class="mb-4">
                        <p class="text-sm text-gray-400 mb-2">Select rules to apply (in order):</p>
                        <div class="flex flex-wrap gap-2 mb-3">
                            <template x-for="rule in availableRules" :key="rule.type">
                                <button @click="toggleNewRule(rule)"
                                        :class="isRuleSelected(rule.type) ? 'bg-discord-blurple text-white' : 'bg-discord-dark text-gray-300 hover:bg-discord-light'"
                                        class="px-3 py-1.5 rounded-lg text-sm border border-gray-600 transition-colors"
                                        x-text="rule.name">
                                </button>
                            </template>
                        </div>
                        
                        <!-- Show value inputs for prefix/suffix -->
                        <template x-for="(rule, index) in newCustomRules" :key="index">
                            <div x-show="rule.has_value" class="flex items-center gap-2 mb-2">
                                <span class="text-sm text-gray-400 w-24" x-text="rule.type + ':'"></span>
                                <input type="text" 
                                       x-model="rule.value"
                                       placeholder="Enter value..."
                                       class="flex-1 bg-discord-dark border border-gray-600 rounded-lg px-3 py-1.5 text-white placeholder-gray-500 focus:outline-none focus:border-discord-blurple text-sm">
                            </div>
                        </template>
                    </div>
                    
                    <!-- Preview -->
                    <div x-show="newCustomRules.length > 0" class="mb-4 p-3 bg-discord-dark rounded-lg">
                        <p class="text-xs text-gray-500 mb-1">Preview:</p>
                        <p class="text-white">"Mario" → "<span x-text="previewTransform('Mario')"></span>"</p>
                    </div>
                    
                    <button @click="addCustomChannel()"
                            :disabled="!newCustomChannelId.trim() || !newCustomChannelName.trim() || newCustomRules.length === 0"
                            class="px-4 py-2 bg-discord-blurple hover:bg-opacity-80 disabled:bg-gray-600 disabled:cursor-not-allowed rounded-lg text-white font-medium transition-colors">
                        Add Custom Channel
                    </button>
                </div>
                
                <!-- Custom channel list -->
                <div x-show="customChannels.length > 0" class="space-y-3">
                    <template x-for="channel in customChannels" :key="channel.id">
                        <div class="bg-discord-darker rounded-lg p-4">
                            <div class="flex items-center justify-between mb-3">
                                <div>
                                    <span class="text-white font-medium" x-text="channel.channel_name"></span>
                                    <span class="text-xs text-gray-500 ml-2" x-text="'#' + channel.channel_id"></span>
                                </div>
                                <button @click="deleteCustomChannel(channel.id)"
                                        class="text-gray-500 hover:text-discord-red transition-colors">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="flex flex-wrap gap-1">
                                <template x-for="rule in channel.rules" :key="rule.type">
                                    <span class="px-2 py-1 bg-discord-blurple/30 text-discord-blurple rounded text-xs"
                                          x-text="rule.value ? rule.type + ': ' + rule.value : rule.type">
                                    </span>
                                </template>
                            </div>
                        </div>
                    </template>
                </div>
                
                <!-- Empty state -->
                <div x-show="customChannels.length === 0" class="text-center py-8 text-gray-500">
                    <p>No custom channels. Add one to apply special transformations!</p>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
function guildSettings(guildId) {
    return {
        guildId: guildId,
        guild: {},
        nicknames: [],
        includedChannels: [],
        memberNicknames: [],
        memberPage: 1,
        memberPageSize: 10,
        memberTotal: 0,
        memberStaleDays: 30,
        memberLoading: false,
        memberRefreshHandle: null,
        memberLastRefresh: null,
        loading: true,
        newNickname: '',
        newChannelId: '',
        newChannelName: '',
		customChannels: [],
        availableRules: [],
        newCustomChannelId: '',
        newCustomChannelName: '',
        newCustomRules: [],
        
        async init() {
            await Promise.all([
                this.loadGuild(),
                this.loadNicknames(),
                this.loadMemberNicknames(),
                this.loadIncludedChannels(),
                this.loadCustomChannels(),
                this.loadAvailableRules()
            ]);
            this.loading = false;
            this.startMemberRefreshTimer();
            window.addEventListener('beforeunload', () => {
                if (this.memberRefreshHandle) {
                    clearInterval(this.memberRefreshHandle);
                }
            });
        },
        
        async loadGuild() {
            const response = await fetch(`/api/guilds/${this.guildId}`);
            if (response.ok) {
                this.guild = await response.json();
            }
        },
        
        async loadNicknames() {
            const response = await fetch(`/api/guilds/${this.guildId}/nicknames`);
            if (response.ok) {
                const data = await response.json();
                this.nicknames = data.nicknames;
            }
        },

        async loadMemberNicknames(page = this.memberPage) {
            this.memberLoading = true;
            const response = await fetch(`/api/guilds/${this.guildId}/member-nicknames?page=${page}&page_size=${this.memberPageSize}`);
            if (response.ok) {
                const data = await response.json();
                this.memberNicknames = data.members.map(member => ({
                    ...member,
                    reset_nickname_input: member.reset_nickname || ''
                }));
                this.memberPage = data.page;
                this.memberPageSize = data.page_size;
                this.memberTotal = data.total;
                this.memberStaleDays = data.stale_days;
                this.memberLastRefresh = new Date().toLocaleTimeString();
            } else {
                this.toast('Failed to load member nicknames', 'error');
            }
            this.memberLoading = false;
        },

        async refreshMemberNicknames() {
            await this.loadMemberNicknames(this.memberPage);
            if (this.memberPage > this.memberPageCount()) {
                await this.loadMemberNicknames(this.memberPageCount());
            }
        },

        startMemberRefreshTimer() {
            if (this.memberRefreshHandle) {
                clearInterval(this.memberRefreshHandle);
            }
            this.memberRefreshHandle = setInterval(() => {
                if (document.visibilityState === 'visible' && !this.memberLoading) {
                    this.refreshMemberNicknames();
                }
            }, 60000);
        },

        async manualRefreshMemberNicknames() {
            if (this.memberLoading) return;
            this.startMemberRefreshTimer();
            await this.refreshMemberNicknames();
        },
        
        async loadIncludedChannels() {
            const response = await fetch(`/api/guilds/${this.guildId}/included-channels`);
            if (response.ok) {
                const data = await response.json();
                this.includedChannels = data.channels;
            }
        },
        
        async updateSettings() {
            const response = await fetch(`/api/guilds/${this.guildId}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    enabled: this.guild.enabled,
                    restore_on_leave: this.guild.restore_on_leave,
                    immunity_role_id: this.guild.immunity_role_id
                })
            });
            
            if (response.ok) {
                this.toast('Settings saved!', 'success');
            } else {
                this.toast('Failed to save settings', 'error');
            }
        },
        
        async toggleEnabled() {
            this.guild.enabled = !this.guild.enabled;
            await this.updateSettings();
        },
        
        async toggleRestore() {
            this.guild.restore_on_leave = !this.guild.restore_on_leave;
            await this.updateSettings();
        },
        
        async addNickname() {
            if (!this.newNickname.trim()) return;
            
            const response = await fetch(`/api/guilds/${this.guildId}/nicknames`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ nickname: this.newNickname.trim() })
            });
            
            if (response.ok) {
                const data = await response.json();
                this.nicknames.push(data);
                this.newNickname = '';
                this.toast('Nickname added!', 'success');
            } else {
                this.toast('Failed to add nickname', 'error');
            }
        },
        
        async deleteNickname(id) {
            const response = await fetch(`/api/guilds/${this.guildId}/nicknames/${id}`, {
                method: 'DELETE'
            });
            
            if (response.ok) {
                this.nicknames = this.nicknames.filter(n => n.id !== id);
                this.toast('Nickname deleted!', 'success');
            } else {
                this.toast('Failed to delete nickname', 'error');
            }
        },

        async saveMemberNickname(member) {
            const response = await fetch(`/api/guilds/${this.guildId}/member-nicknames/${member.user_id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    reset_nickname: member.reset_nickname_input,
                    manual: true
                })
            });

            if (response.ok) {
                const data = await response.json();
                member.reset_nickname = data.reset_nickname;
                member.reset_nickname_manual = data.reset_nickname_manual;
                member.reset_nickname_input = data.reset_nickname || '';
                if (!data.applied) {
                    this.toast('Saved, but failed to apply immediately', 'error');
                } else {
                    this.toast('Member reset nickname updated', 'success');
                }
                await this.refreshMemberNicknames();
            } else {
                const error = await response.json();
                this.toast(error.detail || 'Failed to update member nickname', 'error');
            }
        },

        async removeMemberNickname(member) {
            const response = await fetch(`/api/guilds/${this.guildId}/member-nicknames/${member.user_id}`, {
                method: 'DELETE'
            });

            if (response.ok) {
                this.toast('Member entry removed', 'success');
                await this.refreshMemberNicknames();
            } else {
                const error = await response.json();
                this.toast(error.detail || 'Failed to remove member entry', 'error');
            }
        },

        memberPageCount() {
            if (!this.memberPageSize) return 1;
            return Math.max(1, Math.ceil(this.memberTotal / this.memberPageSize));
        },

        memberPageText() {
            if (this.memberTotal === 0) return 'Page 1 of 1';
            return `Page ${this.memberPage} of ${this.memberPageCount()}`;
        },

        async nextMemberPage() {
            if (this.memberPage >= this.memberPageCount()) return;
            await this.loadMemberNicknames(this.memberPage + 1);
        },

        async prevMemberPage() {
            if (this.memberPage <= 1) return;
            await this.loadMemberNicknames(this.memberPage - 1);
        },

        formatLastSeen(timestamp) {
            if (!timestamp) return 'Last seen: unknown';
            const date = new Date(timestamp);
            if (Number.isNaN(date.getTime())) return 'Last seen: unknown';
            return `Last seen: ${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
        },
        
        async addIncludedChannel() {
            if (!this.newChannelId.trim() || !this.newChannelName.trim()) return;
            
            const response = await fetch(`/api/guilds/${this.guildId}/included-channels`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    channel_id: this.newChannelId.trim(), 
                    channel_name: this.newChannelName.trim() 
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                this.includedChannels.push(data);
                this.newChannelId = '';
                this.newChannelName = '';
                this.toast('Channel added!', 'success');
            } else {
                const error = await response.json();
                this.toast(error.detail || 'Failed to add channel', 'error');
            }
        },
        
        async removeIncludedChannel(id) {
            const response = await fetch(`/api/guilds/${this.guildId}/included-channels/${id}`, {
                method: 'DELETE'
            });
            
            if (response.ok) {
                this.includedChannels = this.includedChannels.filter(c => c.id !== id);
                this.toast('Channel removed!', 'success');
            } else {
                this.toast('Failed to remove channel', 'error');
            }
        },

		async loadCustomChannels() {
            const response = await fetch(`/api/guilds/${this.guildId}/custom-channels`);
            if (response.ok) {
                const data = await response.json();
                this.customChannels = data.channels;
            }
        },
        
        async loadAvailableRules() {
            const response = await fetch('/api/available-rules');
            if (response.ok) {
                const data = await response.json();
                this.availableRules = data.rules;
            }
        },
        
        toggleNewRule(rule) {
            const index = this.newCustomRules.findIndex(r => r.type === rule.type);
            if (index >= 0) {
                this.newCustomRules.splice(index, 1);
            } else {
                this.newCustomRules.push({
                    type: rule.type,
                    has_value: rule.has_value,
                    value: ''
                });
            }
        },
        
        isRuleSelected(ruleType) {
            return this.newCustomRules.some(r => r.type === ruleType);
        },
        
        previewTransform(name) {
            let result = name;
            for (const rule of this.newCustomRules) {
                result = this.applyRule(result, rule);
            }
            return result;
        },
        
        applyRule(text, rule) {
            switch (rule.type) {
                case 'reverse':
                    return text.split('').reverse().join('');
                case 'uppercase':
                    return text.toUpperCase();
                case 'lowercase':
                    return text.toLowerCase();
                case 'sarcastic':
                    return text.split('').map((c, i) => i % 2 ? c.toUpperCase() : c.toLowerCase()).join('');
                case 'leetspeak':
                    return text.replace(/[aeiostl]/gi, c => ({a:'4',e:'3',i:'1',o:'0',s:'$',t:'7',l:'1'}[c.toLowerCase()] || c));
                case 'prefix':
                    return rule.value ? `${rule.value} ${text}` : text;
                case 'suffix':
                    return rule.value ? `${text} ${rule.value}` : text;
                case 'upside_down':
                    const upsideDown = {'a':'ɐ','b':'q','c':'ɔ','d':'p','e':'ǝ','f':'ɟ','g':'ƃ','h':'ɥ','i':'ᴉ','j':'ɾ','k':'ʞ','l':'l','m':'ɯ','n':'u','o':'o','p':'d','q':'b','r':'ɹ','s':'s','t':'ʇ','u':'n','v':'ʌ','w':'ʍ','x':'x','y':'ʎ','z':'z'};
                    return text.toLowerCase().split('').map(c => upsideDown[c] || c).reverse().join('');
                case 'mirror':
                    return text.split('').reverse().join('');
                default:
                    return text;
            }
        },
        
        async addCustomChannel() {
            if (!this.newCustomChannelId.trim() || !this.newCustomChannelName.trim() || this.newCustomRules.length === 0) return;
            
            const response = await fetch(`/api/guilds/${this.guildId}/custom-channels`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    channel_id: this.newCustomChannelId.trim(),
                    channel_name: this.newCustomChannelName.trim(),
                    rules: this.newCustomRules.map(r => ({ type: r.type, value: r.value || null }))
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                this.customChannels.push(data);
                this.newCustomChannelId = '';
                this.newCustomChannelName = '';
                this.newCustomRules = [];
                this.toast('Custom channel added!', 'success');
            } else {
                const error = await response.json();
                this.toast(error.detail || 'Failed to add custom channel', 'error');
            }
        },
        
        async deleteCustomChannel(id) {
            const response = await fetch(`/api/guilds/${this.guildId}/custom-channels/${id}`, {
                method: 'DELETE'
            });
            
            if (response.ok) {
                this.customChannels = this.customChannels.filter(c => c.id !== id);
                this.toast('Custom channel deleted!', 'success');
            } else {
                this.toast('Failed to delete custom channel', 'error');
            }
        },
        
        toast(message, type = 'success') {
            window.dispatchEvent(new CustomEvent('toast', { 
                detail: { message, type, id: Date.now() } 
            }));
        }
    }
}
</script>
{% endblock %}
